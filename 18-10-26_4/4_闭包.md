### 闭包
- 函数套函数，子函数使用父函数的参数或者变量（作用域链，先看函数体内有没有，没有就找参数，还没有就去外面寻找，直到找到window）并且子函数被外界所引用（没被释放），这个时候，父函数的参数或者变量不会被垃圾回收机制回收，此时在浏览器中打印父级的返回值，在scopes下多了一个closure，这就叫闭包Closure
- 函数执行
    1. 开了一个空间（新的作用域）
    2. 形参赋值
    3. 预解释
    4. 从上到下逐行解读代码
    5. 新的作用域销毁
- 应用场景
    1. （私有变量）局部变量不被外界所干扰
        - 再多人开发的时候，在全局作用域下难免会遇到名字重复的情况
            1. 可以使用封闭空间
            ```javascript
            (function(){
                function fn(){
                    alert(1);
                }
                fn();
            })()
            ```
            2. 可以使用命名空间,把变量变成属性，把函数变成方法
            ```javascript
            var my = {
                fn:function(){
                    alert(1);
                }
            };
            my.fn();
            ```
                - 变量、属性
                    变量前面没主，默认主是window；属性前面有主，主就是.前面的对象
                - 函数、方法
                    函数前面没主，默认主是window；方法前面有主，主就是.前面的对象
    - 封闭空间的缺点
        外面想用函数内的运算结果，是不能直接访问到的
        1. return
        2. 挂window下
    2. 储存父函数的参数或者变量
//练习题(1. b1 2. a1 3. d1 4. b1 5. c1 6. d1 7. b1 8. b0d1 9. b0a 10. b0d 5562)
- window.name
    - IE低版本浏览器window下是没有name的
    - 高版本浏览器window下是有name的，并且是字符串，当修改了window.name时，会自动调用toString方法（转成字符串），跟alert一样，也会调用数据类型的toString方法
- 选项卡事件
- 常规
    - 当你点击的时候循环早就结束了，（循环的速度一定必点击要快）
    - 在点击中访问i，此时局部作用域中没有i参数也没有，这个时候会向外找，全局正好有个i，这个i是循环之后的结果，所以就输出i的结果
    - 在事件中，触发事件时，时间绑定的元素是谁this就是谁（事件函数的默认this是触发的元素）
    - 一个东西要关联另一个东西就要索引（给打个标记）
- 闭包
    - 虽然闭包可以把父函数的参数或者变量存储起来，但是对于性能优化是不好的，所以尽量不要使用闭包的存储
- 立即回收
    1. 标记清除法：
        打开页面的时候，先把使用的变量打上标记，如果下次查询之前标记的没被引用，此时就回收
    2. 引用计数法
        变量每用一次就记录一次，一开始是0，下次引用一次就加1，没少引用一次就减1，直到0为止，就删除
    - 如何让变量不再引用，
        - 就是直接给变量赋值一个null即可
### 变量
    var let 
    - let的好处：
        1. 在同一个作用域中不允许有两个相同的名字出现，不然就报错，也包括形参
        2. 不会与window映射
        3. 变量声明的上方有暂存死区
        4. 支持块级作用域，只要有{}都支持块
    const：
    1. 赋值常量不可变
    2. 声明之后必须赋值
    3. 不会和window映射
    4. 也有暂存死区
    5. 支持块级作用域
        - 应用场景：
            1. 一般这个值不会变了，就用常量（用的是他的一变就报错的属性）
            2. 获取静态元素的时候可以使用
### 补充
- 模板字符串
    - `字符串`里面被包着的内容就是字符串 let str = `我的名字叫${name}，我今年${age + 10000}岁`;
    - 普通字符串是不能直接换行的，除非进行字符串拼接，模板字符串是可以随意换行的，可是显示的是换行后的
- 行间自定义属性
    - 当通过js获取元素的时候，这个元素自身有一堆属性和方法，其中id className都是内置的对象属性，只要标签上有内置的属性名，在js获取的时候，就会被映射到获取的元素身上
    - index是自定义的，不是内置的，不能不直接通过.的方式获取，此时：
        1. el.setAttribute(设置的属性名，设置的属性值)                      设置行间属性（box.index2 = 10; 这是对象上的）
        2. el.getAttribute(获取的属性名)，得到属性值，如果获取不到值为null     获取行间属性（console.log(box.index2), 只能通过这种方法获取）
    - 元素对象加自定义属性，用ele.的属性获取