### 作用域 (scope)
    - 域：范围，空间
        - 变量、函数、对象名称的可用性,去探究某段代码它的值（结果）是什么
        - 全局作用域：
            - 1. 当打开浏览器的时候执行js代码，此时的域就是全局作用域,
            - 2. 在浏览器中全局指向windows，
            - 3. 单纯被script标签抱着的范围就是全局作用域，
            - 4. 最大的栈内存，存储简单的数据
            - 打开浏览器的时候js执行分为两步
                1. 变量提升（预解析、预处理）
                    - 在全局只看两个东西（var和function）
                        1. var a = undefined 变量提升
                            - 遇见var不但会找到变量，并且给变量赋值undefined
                            - 如果两个变量名相同，下面的把上面的覆盖
                        2. function
                            - 遇见函数直接把函数名提升，并且赋值为整个代码块
                            - 如果两个函数名相同，下面的把上面的覆盖（只需要最后一个就行了）
                        3. 变量名与函数名一样的情况下
                            - 最终留俩的是代码块，就是函数
                2. 逐行解读代码
                    - 只看"="
                    - 函数声明不会再解读,只在预解析有一次
                    - 函数表达式会解读，带等号
                    - 1. function fn () {} 函数声明 在函数声明的上和下都能执行这个函数
                    - 2. var fn = function () {} 函数表达式 在上面执行函数会报错，因为var会变量提升var fn = undefined undefined不是函数
        - 局部作用域：
            - 在函数或者块里的js的作用范围
    
### 变量和window属性
- 变量：var let
- 属性：var a = ''; window.a
    - 对象的属性
        - 没有才会是undefined，自定义或者自身有的就是后面的值
    - 简单类型的属性
        - 没有是undefined 自定义也是undefined 只有自身带有的属性才是后面的值
    - 当使用var声明一个变量的时候，自动会给window上添加一个同名属性 
    - 有变量的时候和window的属性时相映射的
    - 没有变量的时候，window的属性只有赋值之后才会给window加属性，如果在赋值之前访问这个属性只是undefined
    - 在全局范围中所有的属性、方法都属于window，没有主默认主是window
    - in 是运算符 它能够运算某个属性是不是这个对象的 [语法]; '属性名' in 对象
        - 有：true
        - 没有：false
    - ie浏览器下window下没有name属性
    - 在chrom70版本下，经过实验，如果window中默认的属性的值是字符串，并且在var变量赋值数字之后，结果会为字符串 
    - name
    - defaultStatus
    - status
    - 一般情况下，对象的属性能读能写，写什么就是什么
    - var a = b = 5;
        - var a = 5;
        - b = 5; //b没有var
    - 在赋值之前，先看变量是什么，如果变量undefined还回去window上去查找，赋值的时候window的属性值才会被添加
- 映射
    - 变量和window属性，不是一个东西，但是有映射关系
    - 当没有用var声明的时候，只有赋值window上才会添加这个属性，所以在开发的时候，声明变量必须使用var或者let 
    - 有变量的时候会跟window相映射 在赋值前console.log()这个赋值的东西
        - 变量自己先走预解析
        - 如果window也没有这个属性才是undefined
        - 如果window上有，因为变量和window相映射，所以变量的值就是window属性上有的值
    - 没有变量的时候 在赋值前console.log()这个赋值的东西
        - 如果window上没有这个属性，那么就会报错
        - window上有这个属性，输出的是window的属性值

### 局部作用域
    - 在函数或块中有的作用域
    - 在局部作用域中有自己的一套预解析机制、逐行解读代码并且赋值
    - 有var变量，那么这个变量只存在函数中，跟外面没关系（私有，局部变量）
    - 特点（词法作用域）
        - 如果是函数套函数的情况下，越里面的函数中的变量优先级就越高
        - 子函数没有会去父函数中查找，如果还没有再到外层查找，直到找到window，如果还没有就报错
        - 不能父函数找子函数
    - ES6中有了块的概念
        - {}
        - 使用let或者const是支持块级作用域的，let或者const只会作用于块
        - 如果在块中有声明函数那么在这个块中的任何地方都能找到这个代码块
        - 如果不在这个块中，并且为声明之前访问块中的函数，那么值为undefined
        - 子级没有会去父级中查找
        - {
            console.log(a);//暂存死区 let没有预解释
            let a = 8;
            console.log(a);
        }

### 传参
- 函数内先看有没有变量，如果没有变量就回去找参数有没有
    - 优先级：先找函数内的变量，如果没有变量还会去找参数有没有
    - 参数有：走参数，
        - 如果是简单类型的并且内部修改这个值，外部是不会受到影响的
        - 如果是复合类型的数据，并且内部修改了这个类型的值，外部也是会受到干扰
        - 注意，如果函数内部的参数被赋址了，此时，修改内部对象是不会影响外部的
    - 参数没有就找父级，直到找到window
    - 在函数中，如果有形参并且还有变量，在声明变量的上方访问那么结果就是实参的值