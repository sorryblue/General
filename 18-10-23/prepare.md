### 变量作用域
- 一个变量的作用域(scope)是程序源代码中定义这个变量的区域.
    - 全局变量拥有全局作用域,在jsvacript中的任何地方都都是有定义的
    - 局部变量 在函数内声明的`变量`只在函数体内有定义,他们是局部变量,作用域是局部性的,函数`参数`也是局部变量,他们只在函数体内有定义.
- 优先性
    - 在函数体内,局部变量的优先级高于同名的全局变量,如果在函数内申明的一个局部变量或者函数参数中带有的变量和全局变量重名,那么全局变量就被局部变量所遮盖.
    ```javascript
    var scope = "blobal";               // 申明一个全局变量
    function checkscope () {            // 申明一个同名的局部变量
        var scope = "local";            //返回局部变量的值,而不是全局变量的值
        return scope;
    }
    checkscope();                       // => "local"
    ```
- 尽管在全局作用域编写代码时可以不写var语句,但申明局部变量时必须使用var语句
    ```javascript
    scope = "global";                   // 申明一个全局变量，甚至不用bar来申明
    function checkscope2 () {
        scope = "local";                // 这里修改了全局变量
        myscope = "local";              // 这里申明了一个新的全局变量
        return [scope, myscope];        // 返回两个值
    }
    checkscope2();                      // => ["local", "local"] 产生了副作用
    scope;                              // => "local" 全局变量修改了
    myscope;                            // => "local" 全局命名空间搞乱了
    ```
- 函数定义是可以嵌套的，由于每个函数都有他自己的作用域，因此会出现几个局部作用域嵌套的情况
    ```javascript
    var scope = "global scope";         // 全局变量
    function checkscope () {
        var scope = "local scope";      // 局部变量
        function nested () {
            var scope = "nested scope"; // 嵌套作用域内的局部变量
            return scope;               // 返回当前作用域内的值
        }
        return nested();
    }
    checkscope();                       // => “嵌套作用域”

### 函数作用域和声明提前
- javascript中没有块级作用域，取而代之的使用了函数作用域(function scope): 变量在声明同门的函数体嵌套的任意函数体内都是有定义的。
    ```javascript
    function test (o) {
        var i = 0;                          // i在整个函数体内都是有定义的
        if (typeof o == "object") {
            var j = 0;                      // j在函数体内是有定义的，不仅仅是在这个代码段内
            for (var k = 0; k < 10; k++) {  // k在函数体内都是有定义的，不仅仅是在循环中
                console.log(k);             // 输出数字0~9
            }
            console.log(k);                 // k已经定义了，输出10
        }
        console.log(j);                     // j已经定义了，但可能没有初始化
    }
    ```
    - 在不同的位置定义了变量i,j和k，他们都在痛体格作用域内——着三个变量在函数体内均是有定义的
- javascript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，变量在生命之前甚至已经可用。javascript的这个特性被非正式的称为声明提前(hoisting)(这步操作是在javascript引擎的"预编辑"时进行的，实在代码开始运行之前)即javascript函数里生命的所有变量(但不涉及赋值)都被”提前“至函数体的顶部.
    ```javascript
    var scope = "blobal";
    function f() {
        console.log(scope);     //输出"undefined"，而不是"global"
        var scope = "local";    // 变量在这里附初始值，但变量本身在函数体内任何地方均是有定义的
        console.log(scope);     // 输出"local"
    }
    ```
    - 由于函数作用域的特性,局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量，尽管如此，只有在程序执行到var语句时，局部变量才被真正赋值，等价于，将函数内的变量申明”提前“值函数的整体顶部，同时变量初始值留在原来的位置
    ```javascript
    function f() {
        var scope;              // 在函数顶部啥也没有了局部变量
        console.log(scope);     // 变量存在，但其值为"undefined"
        var scope = "local";    // 变量在这里附初始值，但变量本身在函数体内任何地方均是有定义的
        console.log(scope);     // 这里它具有我们所期望的值
    }
    ```
    - 变量声明放在函数体顶部 使源代码清晰地反映真实的变量作用域
### 作为属性的变量
- 当声明一个javascript全局变量时，实际上是定义了全局对象的一个属性。当使用var声明一个变量时，创建的这个属性是不可配置的也就是说这个变量无法通过delete运算符删除，如果没有使用严格模式并给一个未声明的变量赋值的话，javascript会自动创建一个全局变量，以这种方式创建的变量是全局对象的正常的可配置属性，并可以删除他们
    ```javascript
    var truevar = 1;        //声明一个不可删除的全局变量
    fakevar = 2;            // 创建全局变量的一个可删除的属性
    this.fakevar = 3;       // 同上
    delete truevar;         // => false 变量并没有被删除 
    delete fakevar;         // => true  变量被删除
    delete this.fakevar2;   // => true  变量被删除
    ```
- javascript中全局变量是全局对象的属性，这是在ECMAScript中规范中强制规定的，对于局部变量则没有如此的规定，局部变量当作跟函数调用相关的某个对象的属性。ECMAScript 3 规范称该对象为”调用对象“(call object),ECMAScript 5规范成为”声明上下文对象“(declarative environment record) javascript可以允许使用this关键字来引用全局变量，却没有方法引用局部变量中存放的对象，这种存放局部变量的对象的特有性质，是一种对我们不可兼得内部实现，这种局部变量对象存放的观念是非常重要的
### 作用域链
- javascript是给予语法作用域的语言，全局变量在程序中始终都是有定义的，局部变量在其所潜逃的函数内始终是有定义的
- 如果将一个局部变量看做是自定义实现的对象的属性的话，那么可以换个角度来解读
变量作用域。
- 每一段JavaScript代码（全局代码或函数)都有一个与之关联的作用域链(scope chain)这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需要查找变量x的值的时候（这个过程称做“变量解析”(variable resolution)），它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError)异常。
- 在JavaScript的最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解对象链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别一—在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。