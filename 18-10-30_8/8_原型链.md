### 原型链(_proto_)
- 在JS中所有的实例都有_proto_这个属性
- 除函数以外的对象只有原型链，没有原型
- 函数不但是函数还是Function实例化对象，所以它既有原型也有原型链，而函数的原型只给它的实例化对象使用
- 什么时候会走原型链
    - 当使用这个对象的属性或者方法，自身没有就会走原型链
    - 通过原型链找到它的构造函数的原型
    - 构造函数的原型 === 实例对象的原型链
- 方法
    1. obj.xx = 数据
    2. fn是个构造函数并且return的是当前这个实例function fn(){this.xx = 数据}
    3. 如果找不到数据就找对象的原型链就等同于构造函数的原型
    4. 如果还找不到就会找构造函数原型的原型链就等同于Object.prototype
    5. 如果还没有就真的没有了 Object.prototype下没有原型链了，所以不找了

### constructor
- 对象的原型链下有一个属性，叫做constructor，这个constructor默认指向实例的构造函数（具有参考性的指针），构造函数下的原型上也有个constructor，但是constructor并不可靠，容易被修改，只要改变了构造函数原型的constructor,那么实例的constructor就会改变的，不过就算constructor指向改了，也不会影响代码的正常运行，正常的开发，就算constructor被修改了，也应该及时手动更正，这样方便维护，手动在构造函数的原型下，加上一个constructor，并修正指向

### 包装对象
- 当简单类型去查找一个属性或者方法的时候，默认这个简单类型会转成对象类型，去找已经添加过的属性或者方法，找到之后，**这个对象自动销毁**（活雷锋）
- 简单类型的实例（用new去创建简单类型），虽然是对象类型，但是他们的属性只能读不能写
- valueOf可以看到数据最本质的内容，当new一个简单类型的时候（new String）此时typeof为object，但它实际上是一个字符串，那么可以通过valueOf()去查看数据最本质的内容
- obj.hasOwnProperty('属性名') 看看某个属性是不是对象自己的，会返回一个布尔值
- in运算符，他能够枚举原型//不在变量身上的属性，他会通过原型链去找构造函数的原型上去查找

### for in
- for in 循环 通过枚举对象的属性，来达到循环目的 for(let key in obj){此时的key为属性名，obj[key]就能拿到属性值}
- 凡是能用点(.)的地方都能用中括号，区别在于.后面必须要跟字符串