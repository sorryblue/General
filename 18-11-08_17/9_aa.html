<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
    /*
        1.什么是闭包，举例说明闭包的应用场景
        closure
        函数套函数,子函数引用父函数的参数或者变量,并且子函数被外界引用(没被释放),此时父函数形成闭包,这个时候父级的参数或者变量不会被浏览器垃圾回收机制回收
        闭包多了一定是不好的,
        应用场景:
            减少全局污染
            存储父函数的参数或者变量,为了累计运算

        2.let和var的区别
        let 不会和window映射    没有预解析  支持块作用域    不能重名    
        var 会                  有          支持            可以

        3.什么是高级单例模式、工厂模式
        高级单例模式:   功能更强大的单独实例模式,用一个匿名函数自执行返回一个对象,对象中可以选择暴露对外接口
        工厂模式;   归类,封装达到批量生产的目的(原料,加工,出厂),一般返回的是一个对象

        4.什么是面向对象,你学面向对象的感受？
        把具有相同特征的代码抽象出来,把描述这个类的细节(功能)挂在这个类的原型上的一种设计开发编程思想

        5.函数有哪几种角色各是什么？
        普通函数    类 (构造函数)   对象 -> new Function

        6.new和不new的区别
        new     不加括号也能执行    this默认执行实例    return 复杂类型 = 复杂类型 简单类型 = 实例      默认returm实例
        不new   必须加括号          默认走window        return写啥是啥                               默认return undefined

        7.原型和原型链的关系
        原型 -> 当创建函数的时候自身带有的属性prototype 原型是解决性能问题的,实例上没有就会去构造函数的原型下查找
        原型链 -> 当创建一个对象的时候自身带有的属性_proto_
        实例下的原型链 === 构造函数的原型
        实例没有 -> 类中查看 -> 实例的_proto_ -> 构造函数的原型 -> 构造函数的原型._proto_ -> Object.prototype

        8.this会出现在哪些地方，改变this的方法有哪些
        window:
            fn();
            定时器
            箭头函数暴露在全局
            匿名函数自执行

        对象
            .前面的

        实例化对象
            就是实例

        undefined
            严格模式 'use strict'

        事件
            触发之后this为事件绑定元素

        父级域的
            箭头函数

        改变this
            call
                无数,第一个改变this,第二个参数之后就是实参
            apply
                第二个参数是数组
            bind
                无数参数,调用之后避讳立马执行,二十返回一个改变this的函数,需要手动调用

        9.继承的方式
            call(类式)
                调用父类,call改变this

            拷贝
                for in

                hasOwnproperty

                Object.assgin({},parent)

            原型
                function ph(){}
                ph.protutype == parent.prototype
                children.prototype = new ph

                修改constructor = children

            寄生式组合式
                children.prototype = Object.create(parent.prototype)

            对象继承
                function ph(){}
                ph.prototype = parent.prototypr
                obj._proto_ = parent.prototype

            ES6继承
                class Child estends Parent {
                    constructor(,...arg){
                        super(...arg);
                    }
                }

        10.如何进行数据劫持
                let obj = {
                    num:2
                }
                let n = 2;
                Object.defineProperty(obj,'num',{
                    get(){
                        n += 2;
                        return n;
                    },

                    set(){

                    }
                })
                console.log(obj.num < 5 && obj.num > 5)

        var num = 5;
        var obj = {num: 18};
        obj.fn = (function (num) {
            this.num = num * 5;
            num--;
            return function (n) {
                this.num -= n;
                num++;
                console.log(num);
            }
        })(obj.num);
        var fn = obj.fn;
        fn(3);
        obj.fn(20);
        new obj.fn(10);
        console.log(num, obj.num);

    */
    var num = 5;
        var obj = {num: 18};
        obj.fn = (function (num) {
            this.num = num * 5;
            num--;
            return function (n) {
                this.num -= n;
                num++;
                console.log(num);
            }
        })(obj.num);
        var fn = obj.fn;
        fn(3);
        obj.fn(20);
        new obj.fn(10);
        console.log(num, obj.num);
    </script>
</body>
</html>